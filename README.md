# VR

Домашните задачи се изработени со Unity game engine-от.

<hr />

## Домашна задача 1
Прв чекор во изработката на домашната задача ми беше поставувањето на околината во која играчот ќе се движи. Истата се состои од затворен
простор кој наликува на мал лавиринт. Во неа има неколку препреки кои играчот треба да ги прескокне. Дизајнот на околината е целосно мој.

Наредно беше креирање на објект кој ќе претставува играч и овозможување на истиот да се придвижува и да скока во просторот. 
Ова беше реализирано така што кога погледот ќе се навали за 25 степени или повеќе(максимум 90) према надоле, играчот ќе се придвижи нанапред, 
а пак кога погледот ќе се подигне за исто толку степени према нагоре, играчот ќе скокне. За сето ова да се оствари, најпрвин треба да се додаде модулot GvrEditorEmulator во сцената, кој го овозможува движењето на погледот во апликацијата. Потоа, се креира 
објект на кој се додаваат следниве компоненти: Transform, Rigidbody и Capsule Collider. Подесувањата може да се по лична преференца, освен 
кај Freeze Rotation својството на Rigidbody кое треба да се овозможи за трите оски X, Y и Z. Следно, треба да се постави главната камера како 
подобјект на објектот кој го претставува играчот. По ова, останува уште да се напишат скриптите кои го овозможуваат движењето и скокањето и 
истите да се додадат на објектот. Тоа се скриптите PlayerWalk.cs и PlayerJump.cs соодветно. Логиката која е имплементирана и кај двете е 
многу слична. Најпрвин се проверува дали аголот на погледот е во потребните граници за да се изведе соодветната акција со следните услови:

`Camera.main.transform.eulerAngles.x >= toggleAngle && Camera.main.transform.eulerAngles.x <= 90F` - за движење

`Camera.main.transform.eulerAngles.x <= 360 - toggleAngle && Camera.main.transform.eulerAngles.x >= 360 - 90` - за скок

Забелешка: `toggleAngle` изнесува 25 степени и во двата случаи, но може да се менува по желба.

Потоа доколку условот е исполнет се повикуваат соодветните методи од Rigidbody компонентата кои прават промена на состојбата на објектот,
со соодветни аргументи:

`rb.MovePosition(Vector3 position);` - за движење

`rb.AddForce(Vector3 position, ForceMode mode);` - за скок

Значајна разлика помеѓу двете скрипти е тоа што кај скриптата за скок, пред да се скокне се проверува дали објектот е на земја, за да се
избегне постојано зголемување на висината на објектот. За креирањето на објектот кој го претставува играчот и пишувањето на скриптите
се послужив со неколку различни туторијали, написи на форуми и официјалната документација. Еден видео-туторијал кој би можел да го 
издвојам е следниов: [[Tutorial] Movement In Mobile VR: Look Walk](https://www.youtube.com/watch?v=kBTn2pGwZUk).

За крај, изработив видео на кое е прикажано како играчот се движи низ околината и ги прескокнува препреките кои му се на пат:

<a href="http://www.youtube.com/watch?feature=player_embedded&v=UFX_kmWfi1A
" target="_blank"><img src="http://img.youtube.com/vi/UFX_kmWfi1A/0.jpg" 
alt="IMAGE ALT TEXT HERE" width="640" height="480" border="10" /></a>

<hr />

## Домашна задача 2
Втората домашна задача ја започнав со дизајнирање на изгледот на воведниот екран, екранот со упатството и завршниот екран. Трите екрани се разделени во три различни сцени, посебни од сцената од првата домашна задача. Овие екрани се состојат од копчиња со кои може да се врши интеракција преку задржување на погледот над истите. Копчињата се поставени на Panel објект, кој обезбедува поставување на позадинска боја и истиот е поставен на Canvas објект.

По стартувањето на апликацијата се прикажува воведниот екран. На него има три копчиња. Со "притискање" на првото копче се влегува 
во сцената од првата домашна задача. Во таа сцена се наоѓаме се додека не истече одредено време(ова е реализирано преку скриптата GameTimer.cs, а времето е поставено на 30 секунди), по што ни се прикажува завршниот екран. На завршниот екран има две копчиња, преку кои можеме или да се вратиме во претходната сцена, или да ја прекинеме апликацијата. Второто копче на воведниот екран служи за влез во сцената во која е прикажано упатството за движење и скокање и дополнително има копче преку кое можеме да се вратиме назад кон воведниот екран. Последното копче од воведниот екран е копчето за излез од апликацијата.

За остварување на овие функционалности најпрвин е потребен GvrEditorEmulator, кој овозможува движење на погледот, и GvrEventSystem на кој треба да се додаде компонентата GvrPointerInputModule, преку која се овозможува посакуваната интеракција. Потоа, потребно ни е да имаме главна камера на која ќе и се придружи GvrRecticlePointer објект. Овој објект ни го дава крукчето на екранот, т.е. покажувачот преку кој се врши интеракцијата со копчињата и дополнителни функционалности за остварување на истата. Дополнително, на камерата и е придружен и Canvas објект, на кој пак е придружен Image објект кој има форма на круг којшто е иницијално празен. Преку овој објект се прикажува уште колку време е преостанато пред да се "притисне" копчето. Скриптата која што го овозможува кликнувањето на копчињата преку задржување на погледот над истите е GazeClick.cs. Нејзината имплементација е тривијална и се состои од проверка дали покажувачот се наоѓа над некое од копчињата и доколку е тоа случај, тогаш се мери колку време истиот ќе се задржи над соодветното копче. Ако тоа време надмине некое предефинирано време, тогаш ќе се изврши соодветната акција. Дополнително, се полни и кругот кој што ни прикажува уште колку време ни е преостанато. Кодот кој го овозможува ова е следниот: 
```
if (status) // проверка дали покажувачот се наоѓа над копчето
{
    gazeTime += Time.deltaTime; // акумулирање на поминатото време над копчето
    timerImage.fillAmount = gazeTime / requiredTime; // полнење на кругот за преостанато време
}
if (gazeTime > requiredTime) // проверка дали е надминато предефинираното време
{
    timerImage.fillAmount = 0; // за да се обезбедиме дека во следниот екран кругот на почеток ќе биде празен.
    click.Invoke(); // испалување на настанот
}
```
Оваа скрипта се додава на секое од копчињата. Исто така, на секое од копчињата мора да се додаде и Event Trigger скриптата, која ни ја нуди Unity и да се постават соодветни настани за влез на покажувачот над некое копче и излез надвор од него. Преку нив ќе се менува вредноста на променливата `status` и ќе се ресетираат `gazeTime` и `timerImage.fillAmount` променливите од GazeClick.cs скриптата.

По испалувањето на настанот, потребно е да се промени сцената. За менување на сцените имам напишано посебна скрипта која е именувана како ChangeScene.cs. Менувањето на сцените се изведува преку повик на методот:

`UnityEngine.SceneManagement.SceneManager.LoadScene(sceneName)`

За изработка на оваа домашна задача се послужив со неколку различни туторијали, написи на форуми и официјалната документација. Меѓу нив,
би издвоил два видео-туторијали:

[START MENU in Unity](https://www.youtube.com/watch?v=zc8ac_qUXQY).

[Unity VR Tutorial - Button Gaze Timer Interaction](https://www.youtube.com/watch?v=zdNBZsJdg9c).

За крај, видео во кое се опфатени неколку кориснички сценарија на интеракција:

<a href="http://www.youtube.com/watch?feature=player_embedded&v=rt-NCj4jx_4" 
target="_blank"><img src="http://img.youtube.com/vi/rt-NCj4jx_4/0.jpg" 
alt="IMAGE ALT TEXT HERE" width="640" height="480" border="10" /></a>
