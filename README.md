# VR

Домашните задачи се изработени со Unity game engine-от.

<hr />

## Домашна задача 1
Прв чекор во изработката на домашната задача ми беше поставувањето на околината во која играчот ќе се движи. Истата се состои од затворен простор кој наликува на мал лавиринт. Во неа има неколку препреки кои играчот треба да ги прескокне. Дизајнот на околината е целосно мој.

Наредно беше креирање на објект кој ќе претставува играч и овозможување на истиот да се придвижува и да скока во просторот. 
Ова беше реализирано така што кога погледот ќе се навали за 25 степени или повеќе(максимум 90) према надоле, играчот ќе се придвижи нанапред, а пак кога погледот ќе се подигне за исто толку степени према нагоре, играчот ќе скокне. За сето ова да се оствари, најпрвин треба да се додаде модулot GvrEditorEmulator во сцената, кој го овозможува движењето на погледот во апликацијата. Потоа, се креира 
објект на кој се додаваат следниве компоненти: Transform, Rigidbody и Capsule Collider. Подесувањата може да се по лична преференца, освен кај Freeze Rotation својството на Rigidbody кое треба да се овозможи за трите оски X, Y и Z. Следно, треба да се постави главната камера како подобјект на објектот кој го претставува играчот. По ова, останува уште да се напишат скриптите кои го овозможуваат движењето и скокањето и истите да се додадат на објектот. Тоа се скриптите PlayerWalk.cs и PlayerJump.cs соодветно. Логиката која е имплементирана и кај двете е многу слична. Најпрвин се проверува дали аголот на погледот е во потребните граници за да се изведе соодветната акција со следните услови:

`Camera.main.transform.eulerAngles.x >= toggleAngle && Camera.main.transform.eulerAngles.x <= 90F` - за движење

`Camera.main.transform.eulerAngles.x <= 360 - toggleAngle && Camera.main.transform.eulerAngles.x >= 360 - 90` - за скок

Забелешка: `toggleAngle` изнесува 25 степени и во двата случаи, но може да се менува по желба.

Потоа доколку условот е исполнет се повикуваат соодветните методи од Rigidbody компонентата кои прават промена на состојбата на објектот,
со соодветни аргументи:

`rb.MovePosition(Vector3 position);` - за движење

`rb.AddForce(Vector3 position, ForceMode mode);` - за скок

Значајна разлика помеѓу двете скрипти е тоа што кај скриптата за скок, пред да се скокне се проверува дали објектот е на земја, за да се
избегне постојано зголемување на висината на објектот. Исто така, за дополнителна сигурност е поставен и тајмер кој што оневозможува повеќекратно скокање доколку играчот се наоѓа во некоја специфична состојба. За креирањето на објектот кој го претставува играчот и пишувањето на скриптите се послужив со неколку различни туторијали, написи на форуми и официјалната документација. Еден видео-туторијал кој би можел да го издвојам е следниов: [[Tutorial] Movement In Mobile VR: Look Walk](https://www.youtube.com/watch?v=kBTn2pGwZUk).

За крај, изработив видео на кое е прикажано како играчот се движи низ околината и ги прескокнува препреките кои му се на пат:

<a href="http://www.youtube.com/watch?feature=player_embedded&v=UFX_kmWfi1A
" target="_blank"><img src="http://img.youtube.com/vi/UFX_kmWfi1A/0.jpg" 
alt="Video" width="640" height="480" border="10" /></a>

<hr />

## Домашна задача 2
Втората домашна задача ја започнав со дизајнирање на изгледот на воведниот екран, екранот со упатството и завршниот екран. Трите екрани се разделени во три различни сцени, посебни од сцената од првата домашна задача. Овие екрани се состојат од копчиња со кои може да се врши интеракција преку задржување на погледот над истите. Копчињата се поставени на Panel објект, кој обезбедува поставување на позадинска боја и истиот е поставен на Canvas објект.

По стартувањето на апликацијата се прикажува воведниот екран. На него има три копчиња. Со "притискање" на првото копче се влегува 
во сцената од првата домашна задача. Во таа сцена се наоѓаме се додека не истече одредено време(ова е реализирано преку скриптата GameTimer.cs, а времето е поставено на 30 секунди), по што ни се прикажува завршниот екран. На завршниот екран има две копчиња, преку кои можеме или да се вратиме во претходната сцена, или да ја прекинеме апликацијата. Второто копче на воведниот екран служи за влез во сцената во која е прикажано упатството за движење и скокање и дополнително има копче преку кое можеме да се вратиме назад кон воведниот екран. Последното копче од воведниот екран е копчето за излез од апликацијата.

За остварување на овие функционалности најпрвин е потребен GvrEditorEmulator, кој овозможува движење на погледот, и GvrEventSystem на кој треба да се додаде компонентата GvrPointerInputModule, преку која се овозможува посакуваната интеракција. Потоа, потребно ни е да имаме главна камера на која ќе и се придружи GvrRecticlePointer објект. Овој објект ни го дава крукчето на екранот, т.е. покажувачот преку кој се врши интеракцијата со копчињата и дополнителни функционалности за остварување на истата. Дополнително, на камерата и е придружен и Canvas објект, на кој пак е придружен Image објект кој има форма на круг којшто е иницијално празен. Преку овој објект се прикажува уште колку време е преостанато пред да се "притисне" копчето. Скриптата која што го овозможува кликнувањето на копчињата преку задржување на погледот над истите е GazeClick.cs. Нејзината имплементација е тривијална и се состои од проверка дали покажувачот се наоѓа над некое од копчињата и доколку е тоа случај, тогаш се мери колку време истиот ќе се задржи над соодветното копче. Ако тоа време надмине некое предефинирано време, тогаш ќе се изврши соодветната акција. Дополнително, се полни и кругот кој што ни прикажува уште колку време ни е преостанато. Кодот кој го овозможува ова е следниот: 
```
if (status) // проверка дали покажувачот се наоѓа над копчето
{
    gazeTime += Time.deltaTime; // акумулирање на поминатото време над копчето
    timerImage.fillAmount = gazeTime / requiredTime; // полнење на кругот за преостанато време
}
if (gazeTime > requiredTime) // проверка дали е надминато предефинираното време
{
    timerImage.fillAmount = 0; // за да се обезбедиме дека во следниот екран кругот на почеток ќе биде празен.
    click.Invoke(); // испалување на настанот
}
```
Оваа скрипта се додава на секое од копчињата. Исто така, на секое од копчињата мора да се додаде и Event Trigger скриптата, која ни ја нуди Unity и да се постават соодветни настани за влез на покажувачот над некое копче и излез надвор од него. Преку нив ќе се менува вредноста на променливата `status` и ќе се ресетираат `gazeTime` и `timerImage.fillAmount` променливите од GazeClick.cs скриптата.

По испалувањето на настанот, потребно е да се промени сцената. За менување на сцените имам напишано посебна скрипта која е именувана како ChangeScene.cs. Менувањето на сцените се изведува преку повик на методот:

`UnityEngine.SceneManagement.SceneManager.LoadScene(sceneName)`

За изработка на оваа домашна задача се послужив со неколку различни туторијали, написи на форуми и официјалната документација. Меѓу нив,
би издвоил два видео-туторијали:

[START MENU in Unity](https://www.youtube.com/watch?v=zc8ac_qUXQY).

[Unity VR Tutorial - Button Gaze Timer Interaction](https://www.youtube.com/watch?v=zdNBZsJdg9c).

За крај, видео во кое се опфатени неколку кориснички сценарија на интеракција:

<a href="http://www.youtube.com/watch?feature=player_embedded&v=rt-NCj4jx_4" 
target="_blank"><img src="http://img.youtube.com/vi/rt-NCj4jx_4/0.jpg" 
alt="Video" width="640" height="480" border="10" /></a>

<hr />

## Домашна задача 3
Во третата домашна задача имам имплементирано 3 различни типови на интеракција помеѓу играчот и дадени објекти од сцената, и тоа:

#### 1. Подигнување и носење на коцка, која ќе послужи за да се прескокне една од повисоките препреките
За нејзина имплементација, најпрвин е потребно да се додаде GvrReticlePointer компонента на камерата на играчот, но овој пат, Max Reticle Distance својството треба да е поставено на 2. Со тоа, играчот нема да може да влегува во интеракција со објекти кои се оддалечени од него на растојание поголемо од 2. Исто така, на камерата на играчот се додава и еден празен објект, кој е именуван како Guide, и кој има Box Collider компонента која е иницијално оневозможена. Потоа, се креира нов 3D објект од тип Cube, кој ќе ја претставува коцката. На таквиот објект, покрај стандардните компоненти, му се додаваат и компонентите Rigidbody и EventTrigger. Следно, се креира нова скрипта PickObject.cs, која се додава на коцката, а во која се имплементирани сите методи кои ја овозможуваат интеракцијата. Кога играчот ќе се доближи до коцката на растојание помало од 2 и Reticle Pointer-от ќе покажува кон истата, тогаш се испалува настанот PointerEnter, преку кој се повикува методата `OnPickUp()` од PickObject.cs скриптата. Преку оваа метода, `Transform` објектот на коцката се поставува како дете на `Transform` објектот на Guide објектот. Во оваа метода се извршуваат уште неколку подесувања, меѓу кои едно е овозможувањето на Box Collider компонентата на Guide објектот. Тоа служи за да не се дозволи коцката да "поминува низ ѕидови" кога ќе ја носи играчот. Последно, за да коцката се спушти на земја, откако претходно била подигната, потребно е погледот на играчот да се подигне/навали за одреден агол према нагоре/надолу. Спуштањето на објектот е имплементирано преку `OnPutDown(bool look)` методата, чиј аргумент `look` укажува на тоа во која насока е придвижен погледот(нагоре/надолу). За различна насока на придбижување на погледот, коцката се отпушта на различен начин. Замислено е објектот да се отпушта со подигнување на погледот према нагоре. Другиот начин е поставен само за да се избегне колизија на објектот со површината.

#### 2. Отворање на врата при стоење над даден објект и нејзино повторно затворање откако играчот повеќе не е врз објектот
Потребни се два 3D објекта, од кои едниот ја претставува вратата, а другиот има улога на копче. Копчето е иницијално со црвена боја и е поставено на површината. Доколку играчот застане врз копчето, тоа се обојува зелено и во исто време вратата почнува постепено да се отвора. Во оној момент кога играчот веќе нема да е врз копчето, тоа ќе се обои црвено и вратата ќе почне да се затвора. За да успееме да поминеме низ неа, треба да почекаме таа целосно да се отвори. Скриптата која ја овозможува оваа интеракција е OpenDoor.cs и истата е додадена на објектот кој го претставува копчето. Во неа, потребни ни се објектот кој ќе ја претставува вратата, како и брзините на отворање и затворање. Методите од OpenDoor.cs кои се повикуваат при испалување на настаните кои го регистрираат застанувањето на играчот врз копчето и негово излегување од истото се `OnTriggerEnter()` и `OnTriggerExit()`, соодветно. Преку овие методи се контролира вредноста на `clicked` променливата од истата скрипта. Во зависност од таа вредност, и во зависност од тоа дали вратата е целосно отворена или затворена, во Update() методата се менува векторот на позицијата на `Transform` објектот на вратата.

#### 3. Поместување на препрека преку "притискање" на копче.
Овој тип на интеракција е идентичен на интеракцијата со копчињата од претходната домашна задача. Единствена разлика е тоа што, по "притискање" на копчето, наместо да се смени сцената, се поместува препрека со што се отвара простор низ кој играчот може да помине. Поместувањето се прави преку доделување на нов вектор на позиција на `Transform` објектот на препреката.

Како помош при изработката на домашната задача ми послужија следниве два видео-туторијали:

[Pick up and Move Objects | Unity 2017 Tutorial](https://www.youtube.com/watch?v=JtflOvhOO1Y).

[Unity Beginner Tutorial : Triggers](https://www.youtube.com/watch?v=JHZN_vMqqr4).

Наместо слики за секој вид на интеракција, изработив видео во кое се прикажани истите:

<a href="http://www.youtube.com/watch?feature=player_embedded&v=B0NjzcAvdwU" 
target="_blank"><img src="http://img.youtube.com/vi/B0NjzcAvdwU/0.jpg" 
alt="Video" width="640" height="480" border="10" /></a>
